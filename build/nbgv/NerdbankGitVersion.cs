// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using Nuke.Common.Tools.NerdbankGitVersioning;
//
//    var nerdbankGitVersionConfig = NerdbankGitVersionConfig.FromJson(jsonString);

namespace Nuke.Common.Tools.NerdbankGitVersioning
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class NerdbankGitVersionConfig
    {
        /// <summary>
        /// The x.y version to use particularly for the AssemblyVersionAttribute instead of the
        /// default. This is useful when maintaining assembly binding compatibility on the desktop
        /// .NET Framework is important even though AssemblyFileVersion may change.
        /// </summary>
        [JsonProperty("assemblyVersion", NullValueHandling = NullValueHandling.Ignore)]
        public AssemblyVersionUnion? AssemblyVersion { get; set; }

        /// <summary>
        /// OBSOLETE by v3.0. Use "versionHeightOffset" instead. A number to add to the git height
        /// when calculating the version height (which typically appears as the 3rd integer in a
        /// computed version). May be negative, but not of greater magnitude than the original git
        /// height.
        /// </summary>
        [JsonProperty("buildNumberOffset", NullValueHandling = NullValueHandling.Ignore)]
        public long? BuildNumberOffset { get; set; }

        /// <summary>
        /// Options that are applicable specifically to cloud builds (e.g. VSTS, AppVeyor, TeamCity)
        /// </summary>
        [JsonProperty("cloudBuild", NullValueHandling = NullValueHandling.Ignore)]
        public CloudBuild CloudBuild { get; set; }

        /// <summary>
        /// The git commit prefix (e.g. 'g') in non-public release versions.
        /// </summary>
        [JsonProperty("gitCommitIdPrefix", NullValueHandling = NullValueHandling.Ignore)]
        public string GitCommitIdPrefix { get; set; }

        /// <summary>
        /// When greater than 0, the length of the commit ID will be either this value or the
        /// shortest unambiguous git-abbreviated commit ID possible, whichever is greater. When 0,
        /// the gitCommitIdShortFixedLength property is used instead.
        /// </summary>
        [JsonProperty("gitCommitIdShortAutoMinimum", NullValueHandling = NullValueHandling.Ignore)]
        public long? GitCommitIdShortAutoMinimum { get; set; }

        /// <summary>
        /// The fixed number of characters to use for the commit ID abbreviation length. This
        /// property is ignored if the gitCommitIdShortAutoMinimum property is greater than 0.
        /// </summary>
        [JsonProperty("gitCommitIdShortFixedLength", NullValueHandling = NullValueHandling.Ignore)]
        public long? GitCommitIdShortFixedLength { get; set; }

        /// <summary>
        /// A value indicating whether this file only partially describes the versioning policy, and
        /// that more information should be discovered in an ancestor directory.
        /// </summary>
        [JsonProperty("inherit", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Inherit { get; set; }

        /// <summary>
        /// Details for how and what the generated version for NuGet packages will be.
        /// </summary>
        [JsonProperty("nugetPackageVersion", NullValueHandling = NullValueHandling.Ignore)]
        public NugetPackageVersion NugetPackageVersion { get; set; }

        /// <summary>
        /// An array of pathspec-like strings that are used to filter commits when calculating the
        /// version height. A commit will not increment the version height if its changed files are
        /// not included by these filters.
        /// Paths are relative to this file. Paths relative to the root of the repository can be
        /// specified with the `:/` prefix.
        /// Exclusions can be specified with a `:^` prefix for relative paths, or a `:^/` prefix for
        /// paths relative to the root of the repository.
        /// After a path matches any non-exclude filter, it will be run through all exclude filters.
        /// If it matches, the path is ignored.
        /// </summary>
        [JsonProperty("pathFilters", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> PathFilters { get; set; }

        /// <summary>
        /// An array of regular expressions that may match a ref (branch or tag) that should be built
        /// with PublicRelease=true as the default value. The ref matched against is in its canonical
        /// form (e.g. refs/heads/master)
        /// </summary>
        [JsonProperty("publicReleaseRefSpec", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> PublicReleaseRefSpec { get; set; }

        /// <summary>
        /// Settings for the prepare-release command
        /// </summary>
        [JsonProperty("release", NullValueHandling = NullValueHandling.Ignore)]
        public Release Release { get; set; }

        /// <summary>
        /// The minimum number of digits to use for numeric identifiers in SemVer 1.
        /// </summary>
        [JsonProperty("semVer1NumericIdentifierPadding", NullValueHandling = NullValueHandling.Ignore)]
        public long? SemVer1NumericIdentifierPadding { get; set; }

        /// <summary>
        /// The major.minor-pre version to use as the basis for version calculations. If {height} is
        /// not used in this value and the value has fewer than the full major.minor.build.revision
        /// specified, ".{height}" will be appended by the build.
        /// </summary>
        [JsonProperty("version", NullValueHandling = NullValueHandling.Ignore)]
        public string Version { get; set; }

        /// <summary>
        /// A number to add to the git height when calculating the version height (which typically
        /// appears as the 3rd integer in a computed version). May be negative, but not of greater
        /// magnitude than the original git height.
        /// </summary>
        [JsonProperty("versionHeightOffset", NullValueHandling = NullValueHandling.Ignore)]
        public long? VersionHeightOffset { get; set; }
    }

    public partial class AssemblyVersionClass
    {
        /// <summary>
        /// Identifies the last component to be explicitly set in the version.
        /// </summary>
        [JsonProperty("precision", NullValueHandling = NullValueHandling.Ignore)]
        public Precision? Precision { get; set; }

        [JsonProperty("version", NullValueHandling = NullValueHandling.Ignore)]
        public string Version { get; set; }
    }

    /// <summary>
    /// Options that are applicable specifically to cloud builds (e.g. VSTS, AppVeyor, TeamCity)
    /// </summary>
    public partial class CloudBuild
    {
        /// <summary>
        /// Override the build number preset by the cloud build with one enriched with version
        /// information.
        /// </summary>
        [JsonProperty("buildNumber", NullValueHandling = NullValueHandling.Ignore)]
        public BuildNumber BuildNumber { get; set; }

        /// <summary>
        /// Elevates all build properties to cloud build variables prefaced with "NBGV_"
        /// </summary>
        [JsonProperty("setAllVariables", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SetAllVariables { get; set; }

        /// <summary>
        /// Elevate certain calculated version build properties to cloud build variables.
        /// </summary>
        [JsonProperty("setVersionVariables", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SetVersionVariables { get; set; }
    }

    /// <summary>
    /// Override the build number preset by the cloud build with one enriched with version
    /// information.
    /// </summary>
    public partial class BuildNumber
    {
        /// <summary>
        /// Whether to override the build number preset by the cloud build.
        /// </summary>
        [JsonProperty("enabled", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Enabled { get; set; }

        /// <summary>
        /// Describes when and where to include information about the git commit being built.
        /// </summary>
        [JsonProperty("includeCommitId", NullValueHandling = NullValueHandling.Ignore)]
        public IncludeCommitId IncludeCommitId { get; set; }
    }

    /// <summary>
    /// Describes when and where to include information about the git commit being built.
    /// </summary>
    public partial class IncludeCommitId
    {
        /// <summary>
        /// The conditions when the commit ID is included in the build number.
        /// </summary>
        [JsonProperty("when", NullValueHandling = NullValueHandling.Ignore)]
        public When? When { get; set; }

        /// <summary>
        /// The position to include the commit ID information.
        /// </summary>
        [JsonProperty("where", NullValueHandling = NullValueHandling.Ignore)]
        public Where? Where { get; set; }
    }

    /// <summary>
    /// Details for how and what the generated version for NuGet packages will be.
    /// </summary>
    public partial class NugetPackageVersion
    {
        /// <summary>
        /// The version of SemVer (e.g. 1 or 2) that should be used when generating the package
        /// version.
        /// </summary>
        [JsonProperty("semVer", NullValueHandling = NullValueHandling.Ignore)]
        public long? SemVer { get; set; }
    }

    /// <summary>
    /// Settings for the prepare-release command
    /// </summary>
    public partial class Release
    {
        /// <summary>
        /// Defines the format of release branch names. Format must include a placeholder '{version}'
        /// for the version
        /// </summary>
        [JsonProperty("branchName", NullValueHandling = NullValueHandling.Ignore)]
        public string BranchName { get; set; }

        /// <summary>
        /// Specifies the first/default prerelease tag for new versions
        /// </summary>
        [JsonProperty("firstUnstableTag", NullValueHandling = NullValueHandling.Ignore)]
        public string FirstUnstableTag { get; set; }

        /// <summary>
        /// Specifies which part of the version on the current branch is incremented when preparing a
        /// release.
        /// </summary>
        [JsonProperty("versionIncrement", NullValueHandling = NullValueHandling.Ignore)]
        public VersionIncrement? VersionIncrement { get; set; }
    }

    /// <summary>
    /// Identifies the last component to be explicitly set in the version.
    /// </summary>
    public enum Precision { Build, Major, Minor, Revision };

    /// <summary>
    /// The conditions when the commit ID is included in the build number.
    /// </summary>
    public enum When { Always, Never, NonPublicReleaseOnly };

    /// <summary>
    /// The position to include the commit ID information.
    /// </summary>
    public enum Where { BuildMetadata, FourthVersionComponent };

    /// <summary>
    /// Specifies which part of the version on the current branch is incremented when preparing a
    /// release.
    /// </summary>
    public enum VersionIncrement { Build, Major, Minor };

    /// <summary>
    /// The x.y version to use particularly for the AssemblyVersionAttribute instead of the
    /// default. This is useful when maintaining assembly binding compatibility on the desktop
    /// .NET Framework is important even though AssemblyFileVersion may change.
    /// </summary>
    public partial struct AssemblyVersionUnion
    {
        public AssemblyVersionClass AssemblyVersionClass;
        public string String;

        public static implicit operator AssemblyVersionUnion(AssemblyVersionClass AssemblyVersionClass) => new AssemblyVersionUnion { AssemblyVersionClass = AssemblyVersionClass };
        public static implicit operator AssemblyVersionUnion(string String) => new AssemblyVersionUnion { String = String };
    }

    public partial class NerdbankGitVersionConfig
    {
        public static NerdbankGitVersionConfig FromJson(string json) => JsonConvert.DeserializeObject<NerdbankGitVersionConfig>(json, Nuke.Common.Tools.NerdbankGitVersioning.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this NerdbankGitVersionConfig self) => JsonConvert.SerializeObject(self, Nuke.Common.Tools.NerdbankGitVersioning.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                AssemblyVersionUnionConverter.Singleton,
                PrecisionConverter.Singleton,
                WhenConverter.Singleton,
                WhereConverter.Singleton,
                VersionIncrementConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class AssemblyVersionUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AssemblyVersionUnion) || t == typeof(AssemblyVersionUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new AssemblyVersionUnion { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<AssemblyVersionClass>(reader);
                    return new AssemblyVersionUnion { AssemblyVersionClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type AssemblyVersionUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (AssemblyVersionUnion)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AssemblyVersionClass != null)
            {
                serializer.Serialize(writer, value.AssemblyVersionClass);
                return;
            }
            throw new Exception("Cannot marshal type AssemblyVersionUnion");
        }

        public static readonly AssemblyVersionUnionConverter Singleton = new AssemblyVersionUnionConverter();
    }

    internal class PrecisionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Precision) || t == typeof(Precision?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "build":
                    return Precision.Build;
                case "major":
                    return Precision.Major;
                case "minor":
                    return Precision.Minor;
                case "revision":
                    return Precision.Revision;
            }
            throw new Exception("Cannot unmarshal type Precision");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Precision)untypedValue;
            switch (value)
            {
                case Precision.Build:
                    serializer.Serialize(writer, "build");
                    return;
                case Precision.Major:
                    serializer.Serialize(writer, "major");
                    return;
                case Precision.Minor:
                    serializer.Serialize(writer, "minor");
                    return;
                case Precision.Revision:
                    serializer.Serialize(writer, "revision");
                    return;
            }
            throw new Exception("Cannot marshal type Precision");
        }

        public static readonly PrecisionConverter Singleton = new PrecisionConverter();
    }

    internal class WhenConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(When) || t == typeof(When?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "always":
                    return When.Always;
                case "never":
                    return When.Never;
                case "nonPublicReleaseOnly":
                    return When.NonPublicReleaseOnly;
            }
            throw new Exception("Cannot unmarshal type When");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (When)untypedValue;
            switch (value)
            {
                case When.Always:
                    serializer.Serialize(writer, "always");
                    return;
                case When.Never:
                    serializer.Serialize(writer, "never");
                    return;
                case When.NonPublicReleaseOnly:
                    serializer.Serialize(writer, "nonPublicReleaseOnly");
                    return;
            }
            throw new Exception("Cannot marshal type When");
        }

        public static readonly WhenConverter Singleton = new WhenConverter();
    }

    internal class WhereConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Where) || t == typeof(Where?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "buildMetadata":
                    return Where.BuildMetadata;
                case "fourthVersionComponent":
                    return Where.FourthVersionComponent;
            }
            throw new Exception("Cannot unmarshal type Where");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Where)untypedValue;
            switch (value)
            {
                case Where.BuildMetadata:
                    serializer.Serialize(writer, "buildMetadata");
                    return;
                case Where.FourthVersionComponent:
                    serializer.Serialize(writer, "fourthVersionComponent");
                    return;
            }
            throw new Exception("Cannot marshal type Where");
        }

        public static readonly WhereConverter Singleton = new WhereConverter();
    }

    internal class VersionIncrementConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(VersionIncrement) || t == typeof(VersionIncrement?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "build":
                    return VersionIncrement.Build;
                case "major":
                    return VersionIncrement.Major;
                case "minor":
                    return VersionIncrement.Minor;
            }
            throw new Exception("Cannot unmarshal type VersionIncrement");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (VersionIncrement)untypedValue;
            switch (value)
            {
                case VersionIncrement.Build:
                    serializer.Serialize(writer, "build");
                    return;
                case VersionIncrement.Major:
                    serializer.Serialize(writer, "major");
                    return;
                case VersionIncrement.Minor:
                    serializer.Serialize(writer, "minor");
                    return;
            }
            throw new Exception("Cannot marshal type VersionIncrement");
        }

        public static readonly VersionIncrementConverter Singleton = new VersionIncrementConverter();
    }
}
